
将错误的尝试保留在上下文中。当模型看到一个失败的行动——以及由此产生的观察结果或堆栈跟踪——它会隐式地更新其内部信念。这会改变其先验，降低重复相同错误的可能性。 事实上，我们认为错误恢复是真正代理行为的最明显指标之一。然而，在大多数学术工作和公共基准测试中，这一点仍然代表性不足，它们通常关注理想条件下的任务成功。

---

# 借鉴Manus使用todo方法
Manus使用todo.md的核心机制，本质上是一种 “通过外部状态管理，强制刷新注意力焦点” 的策略。这对于解决长链条任务中的“目标漂移”和“上下文遗忘”问题极其有效。

让我们借鉴这个思路，彻底重新设计您的平台的上下文输出流程。我们将从之前的“一次性注入”上下文（洋葱模型），升级为一种 “动态、自我修正的执行计划” 模式。

### 重新设计的流程：基于动态执行计划的上下文管理

我们将引入一个核心概念：EXECUTION_PLAN.md。这不仅仅是一个待办事项列表，它是AI在执行一个开发步骤时的 “工作台”和“短期记忆”。

这个流程分为两个阶段：初始化阶段 和 循环执行阶段。

###  阶段一：初始化 - 生成初始执行计划
这个阶段的目标是：利用我们之前设计的“洋葱模型”的丰富信息，生成一份高质量的、给AI自己看的、详细的初始行动计划。

用户触发任务： 用户在UI上点击某个开发步骤，例如：“12. 实现文章点赞数增加的核心逻辑”。

上下文引擎“简报”： 您的平台后台的“上下文引擎”像之前一样，快速整合“洋葱模型”的四层信息（任务指令、代码环境、功能意图、项目规范），形成一个结构化的JSON对象。

AI的第一个动作：制定计划 (Plan Generation)

平台将整合好的JSON上下文，连同一个指令，发给LLM。

指令： “你是一名资深软件架构师。请根据以下完整的上下文信息，为一名开发者（AI Agent）制定一份详细、分步的执行计划。这份计划应该以Markdown清单的格式呈现。只输出这份计划。”

AI的输出： AI此时 不写任何代码，而是生成 EXECUTION_PLAN.md 的初始版本。

EXECUTION_PLAN.md (V1) 示例:
```
# 执行计划：实现文章点赞功能的核心逻辑

**## 最终目标 (Objective)**
在 `LikeService` 中创建一个 `IncrementLikeCount` 方法，用于安全地增加文章的点赞数。

**## 验收标准 (Acceptance Criteria)**
- [ ] 成功后，数据库中对应文章的点赞数字段+1。
- [ ] 如果文章不存在，必须返回明确的错误。
- [ ] 并发调用下，点赞数必须保证最终一致性。

---

**## 行动清单 (Action Checklist)**
- [ ] **步骤1: 读取文件** - 读取 `services/like_service.go` 的当前内容，以了解现有结构。
- [ ] **步骤2: 定义方法** - 在 `LikeService` 结构体上，添加 `IncrementLikeCount` 方法的签名。
- [ ] **步骤3: 实现业务逻辑 - 查找文章** - 调用数据库模块获取文章实体。
- [ ] **步骤4: 实现业务逻辑 - 处理文章不存在的情况** - 如果文章为空，返回一个包装后的错误。
- [ ] **步骤5: 实现业务逻辑 - 增加点赞数** - 对文章实体的 `LikeCount` 字段执行 `+1` 操作。
- [ ] **步骤6: 实现业务逻辑 - 持久化更新** - 调用数据库模块将更新后的文章实体保存。
- [ ] **步骤7: 编写单元测试** - 创建 `services/like_service_test.go` 文件，并为 `IncrementLikeCount` 方法编写至少3个测试用例（成功、文章不存在、并发）。
- [ ] **步骤8: 执行测试** - 运行所有新编写的单元测试。
- [ ] **步骤9: 最终审查** - 检查所有代码是否符合项目规范（驼峰命名、错误处理、日志）。
- [ ] **步骤10: 完成任务** - 所有步骤检查无误，输出最终的代码变更。


---

**## 上下文快照 & 约束 (Context & Constraints)**
* **架构:** 微服务, gRPC通信, 禁止跨库调用。
* **规范:** 错误处理使用 `errors.Wrap`。
* **关键数据模型:** `type Article struct { ID string; LikeCount int }`

**## 工作台 (Scratchpad)**
* **上次动作结果:** 无
  阶段二：循环执行 - AI的“工作循环”
  这是借鉴Manus思想的核心。AI进入一个循环，在每次循环中，它都会 重读并重写 整个 EXECUTION_PLAN.md。


```

##### 工作循环的每一步:

**读取计划 (Read the Plan):**

在决定下一步做什么之前，AI Agent的上下文 总是以当前的 EXECUTION_PLAN.md 的全文开始。这是最重要的改变。

**决定动作 (Decide the Action):**

AI查看清单，找到第一个未勾选 [ ] 的项目。例如，“步骤1: 读取文件”。

A**I决定调用一个内部工具：** tool.readFile("services/like_service.go")。

**执行动作 (Execute the Action):**

平台执行该工具调用，并获得结果（文件内容或错误信息）。

**更新并重写计划 (Update & Rewrite the Plan):**

AI现在 生成一个新的、完整的 EXECUTION_PLAN.md (V2)。

它将 [ ] 步骤1 修改为 [x] 步骤1。

它将动作的结果记录在 工作台 部分。

这个重写的动作，将整个计划连同最新的进展，一起推到了上下文窗口的最末端，强制AI“刷新”了对全局目标的注意力。

EXECUTION_PLAN.md (V2 - 经过第一次循环后) 示例:

```Markdown
# 执行计划：实现文章点赞功能的核心逻辑

... (目标和验收标准部分不变) ...

---

**## 行动清单 (Action Checklist)**
- [x] ~~**步骤1: 读取文件** - 读取 `services/like_service.go` 的当前内容，以了解现有结构。~~
- [ ] **步骤2: 定义方法** - 在 `LikeService` 结构体上，添加 `IncrementLikeCount` 方法的签名。
- [ ] **步骤3: 实现业务逻辑 - 查找文章** - ...
  ... (其他步骤不变) ...

---

**## 上下文快照 & 约束 (Context & Constraints)**
... (不变) ...

**## 工作台 (Scratchpad)**
* **上次动作结果:** 成功读取 `services/like_service.go`。文件内容如下：
    ```go
    package services
    // ... (现有文件内容) ...
    type LikeService struct {
        // ...
    }
    ```
```



**进入下一次循环:**

AI再次以 V2 版本的全文作为上下文，看到在c,   下一步是“步骤2: 定义方法”。

它决定生成代码片段来实现方法签名，然后再次更新计划，勾选步骤2，并将生成的代码片段放入工作台，生成 V3 版本...

如果某一步（如步骤8执行测试）失败了，上次动作结果 会记录失败信息。在下一次循环中，AI看到失败结果，就可能不会继续勾选下一步，而是决定 动态修改计划，比如在清单中插入一个新步骤：“步骤8.1: 修正代码以解决测试失败问题”。这就是 自我修正 能力的体现。

